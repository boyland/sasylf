/*
 * Based on Sun's example Java grammar from JavaCC.
 * The copyright statement for the Java grammar is below.
 * Used by permission via the JavaCC license from Sun, included as the LICENSE
 * in this directory.  This file is thus covered by both the Eclipse Public License
 * used by SASyLF and Sun's license for JavaCC.
 */

/*
 * Copyright Â© 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lisfts is strictly prohibited.
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(DSLToolkitParser)

package edu.cmu.cs.sasylf.parser;

import edu.cmu.cs.sasylf.ast.*;

import static edu.cmu.cs.sasylf.util.Util.*;
import edu.cmu.cs.sasylf.util.*;

import java.io.*;
import java.util.*;

@SuppressWarnings({"unused","serial"})
public class DSLToolkitParser {
    public static String currentFile = "NONE";

	// thread invariant: the volatile field points to an immutable array
	// the volatile field is only changed while holding the DSLToolkitParser lock
    private static volatile CommentListener[] listeners = new CommentListener[0];

    /**
     * Add a comment listener to the listeners for all parsers.
     * @param l listener, must not be null 
     */
    public static void addListener(CommentListener l) {
        if (l == null) throw new NullPointerException("listener is null");
        boolean inProgress = true;
        do { 
            CommentListener[] previous = listeners;
            CommentListener[] proposed = new CommentListener[previous.length+1];
            for (int i=0; i < previous.length; ++i) {
                proposed[i] = previous[i];
            }
            proposed[previous.length] = l;
            synchronized (DSLToolkitParser.class) {
                if (listeners == previous) {
                    listeners = proposed;
                    inProgress = false;
                }
            }
        } while (inProgress);
    }

    /**
     * Remove a comment listener for all parsers.
     * If the listeners include this listener, it is removed
     * and we return true.  Otherwise, return false.
     * If it is present multiple times, only the first instance is removed.
     * @param listener to remove
     * @return whether the listener was present (and removed).
     */
    public static boolean remListener(CommentListener l) {
        boolean inProgress = true;
        do { 
            CommentListener[] previous = listeners;
            CommentListener[] proposed = new CommentListener[previous.length-1];
			boolean found = false;
            for (int i=0; i < previous.length; ++i) {
                if (found) proposed[i-1] = previous[i];
                else if (previous[i] == l) found = true;
                else if (i == proposed.length-1) return false;
                else proposed[i] = previous[i];
            }
            synchronized (DSLToolkitParser.class) {
                if (listeners == previous) {
                    listeners = proposed;
                    inProgress = false;
                }
            }
        } while (inProgress);
        return true;
    }

    protected static void commentRead(Token t) {
        for (CommentListener l : listeners) {
            l.commentRead(t,currentFile);
        }
    }
    
    public Token firstToken = null;

    public static CompUnit read(File f) throws FileNotFoundException, IOException, ParseException {
        InputStream fi = new FileInputStream(f);
        try {
                        DSLToolkitParser parser;
                        parser = new DSLToolkitParser(fi,"UTF-8");
                        currentFile = f.toString();
                        return parser.CompilationUnit();
        } catch (ParseException e) {
                System.err.println(e.getMessage());
                //ErrorHandler.report(e.getMessage(), null);
                throw e;
                //return null; // unreachable
        } finally {
                fi.close();
        }
    }
    
    public static CompUnit read(String filename, InputStream is) throws ParseException {
      DSLToolkitParser parser = new DSLToolkitParser(is,"UTF-8");
      currentFile = filename;
      return parser.CompilationUnit();
    }

    public static CompUnit read(String filename, Reader r) throws ParseException {
      DSLToolkitParser parser = new DSLToolkitParser(r);
      currentFile = filename;
      return parser.CompilationUnit();   
    }

    // If new keywords are added: these must be updated:
    private static final int FIRST_KEYWORD = DSLToolkitParserConstants.PACKAGE;
    private static final int LAST_KEYWORD = DSLToolkitParserConstants.WHERE;
    
    public static String[] allKeywords() {
      String[] result = new String[LAST_KEYWORD-FIRST_KEYWORD+1];
      for (int i= FIRST_KEYWORD; i <= LAST_KEYWORD; ++i) {
        String quotedKeyword = DSLToolkitParserConstants.tokenImage[i];
        int n = quotedKeyword.length();
        result[i-FIRST_KEYWORD] = quotedKeyword.substring(1,n-1);
      }
      return result;
    }

	/** True if the next thing is another top-level declaration
	*/
	boolean isTopLevel() {
	  Token t = getToken(1);
	  return t.kind == TERMINALS
	      || t.kind == SYNTAX
	      || t.kind == ABSTRACT
	      || t.kind == JUDGMENT
	      || t.kind == LEMMA
	      || t.kind == THEOREM
	      || t.kind == USE
	      || t.kind == EXTENDS;
	}
	      
    /** True if the next token is almost anything but not
     * PIPE
     * LPAREN, RPAREN, LBRACK, RBRACK,
     * AND, NOT, OR
     * other keywords too.
     * These are the things that can be in the concrete syntax
     * using in syntax definitions, judgments forms and derivations.
     */
    boolean isTermNoBAR() {
		return getToken(1).kind == IDENTIFIER
	        /* || (getToken(1).kind == DOT && notNL(getToken(2).specialToken)) */
			|| getToken(1).kind == STRING_LITERAL
			|| getToken(1).kind == OPERATOR
			|| getToken(1).kind == COLON
			|| getToken(1).kind == COLON_EQ
			|| getToken(1).kind == DOT
			|| getToken(1).kind == EQUAL
			|| getToken(1).kind == SEMICOLON
			|| getToken(1).kind == MINUS
			|| getToken(1).kind == PLUS
			|| getToken(1).kind == TIMES
			|| getToken(1).kind == COMMA
			|| getToken(1).kind == LBRACE
			|| getToken(1).kind == RBRACE
			|| getToken(1).kind == CASE
			|| getToken(1).kind == END
			|| getToken(1).kind == CONTRADICTION
			|| getToken(1).kind == DO
			|| getToken(1).kind == MODULE
			// || getToken(1).kind == NOT
			// || getToken(1).kind == OR
			|| getToken(1).kind == EXTENDS
			|| getToken(1).kind == USE
			|| getToken(1).kind == REQUIRES
			|| getToken(1).kind == PROVIDES
			|| getToken(1).kind == INTEGER_LITERAL;
    }    

    boolean isTerm() {
    	return isTermNoBAR() || getToken(1).kind == PIPE;  
    }

	boolean notNL(Token tok) {
		return tok == null || tok.kind != NL && tok.kind != SINGLE_LINE_COMMENT && notNL(tok.specialToken);
	}

	void afterBAR() {
	  if (!notNL(getToken(1))) {
	    ErrorHandler.recoverableError(Errors.RULE_NAME_EXPECTED,new Location(token));
	  }
	}

    boolean isTermNoBARNL() {
        boolean result = isTermNoBAR();
        return result && notNL(getToken(1).specialToken);
    }
  
    boolean isTermNoNL() {
    	boolean result = isTerm();
		return result && notNL(getToken(1).specialToken);
    }

    boolean lParenNoNL() {
    	return getToken(1).kind == LPAREN && notNL(getToken(1).specialToken);
    }

    boolean isLogicNoNL() { // vestigial for partial "not" support
      Token t = getToken(1);
      return (t.kind == NOT) && notNL(t.specialToken);
    }

    boolean isVarBindingArg() {
		return (getToken(1).kind == IDENTIFIER && getToken(2).kind == RBRACK);
    }

    boolean isBinding() {
		return getToken(1).kind == IDENTIFIER && getToken(2).kind == LBRACK;
    }

    boolean isRuleNamePiece(Token t) {
		return
		  (t.kind == MINUS ||
		   t.kind == PLUS ||
		   t.kind == TIMES ||
		   t.kind == IDENTIFIER || 
		   t.kind == INTEGER_LITERAL ||
		   t.kind == OPERATOR ||
		   t.kind == THEOREM ||
		   t.kind == LEMMA ||
		   // list every keyword from Keyword():
		   t.kind == AND || 
		   t.kind == CASE ||
		   t.kind == CONTRADICTION ||
		   t.kind == DO ||
		   t.kind == END ||
		   t.kind == EXCHANGE ||
		   t.kind == EXTENDS ||
		   t.kind == IS || 
		   t.kind == INVERSION ||
		   t.kind == MODULE ||
		   t.kind == NOT ||
		   t.kind == OR ||
		   t.kind == PROVIDES ||
		   t.kind == REQUIRES ||
		   t.kind == SUBSTITUTION ||
		   t.kind == USE || 
		   t.kind == WEAKENING);
    }

    boolean isRulePartToken(Token t) {
		return t.specialToken == null && isRuleNamePiece(t);
    }
        
    boolean isRulePart() {
        return isRulePartToken(getToken(1));
    }
    
    boolean isRulePart2() {
        return isRuleNamePiece(getToken(1)) && isRulePartToken(getToken(2)); 
    }
    
    NonTerminal getNonTerminal(Token t) {
		NonTerminal nt = new NonTerminal(t.image, new Location(t));
		return nt;
    }
    Clause clauseFor(Token t) {
    	Element e = getNonTerminal(t);
   	  	Clause cl = new Clause(e);
   	  	cl.add(e);
   	  	return cl;
    }
    Terminal getTerminal(Token t) {
		return getTerminal(t, t.image);
    }
    Terminal getTerminal(Token t, String s) {
		Terminal tm = new Terminal(s, makeSpan(t));
		return tm;
    }
    
    Span makeSpan(Token t) {
        Location loc = new Location(t);
        return new DefaultSpan(loc,loc.add(t.image.length()));
    }
}

PARSER_END(DSLToolkitParser)


/* WHITE SPACE */

SPECIAL_TOKEN :
{
  < WHITESPACE: ( " " | "\t" | "\f" | "\r" | "\u00a0")+ >
}

SPECIAL_TOKEN : 
{
	< NL: "\n" >
}

SPECIAL_TOKEN : {
    < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
    {
      DSLToolkitParser.commentRead(matchedToken);
    }
} 
   
/* COMMENTS */

MORE :
{
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > 
    {
      DSLToolkitParser.commentRead(matchedToken);
    }
    : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" >
    {
      DSLToolkitParser.commentRead(matchedToken);
    }
    : DEFAULT
}

<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < PACKAGE: "package" >
| < JUDGMENT: "judgment" >
| < TERMINALS: "terminals" >
| < PREMISE: "premise" >
| < SYNTAX: "syntax" >
| < THEOREM: "theorem" >
| < LEMMA: "lemma" >
| < FORALL: "forall" >
| < EXISTS: "exists" >
| < BY: "by" >
| < RULE: "rule" >
| < IS: "is" >
| < ON: "on" >
| < END: "end" >
| < CASE: "case" >
| < ANALYSIS: "analysis" >
| < ASSUMES: "assumes" >
| < SUBSTITUTION: "substitution" >
| < INDUCTION: "induction" >
| < INVERSION: "inversion" >
| < WEAKENING: "weakening" >
| < EXCHANGE: "exchange" >
| < CONTRACTION: "contraction" >
| < HYPOTHESIS: "hypothesis" >
| < UNPROVED: "unproved" >
| < SOLVE: "solve" >
| < AND: "and" >
| < OR: "or" >
| < NOT: "not" >
| < PROOF: "proof" >
| < CONTRADICTION: "contradiction" >
| < USE: "use" >
| < MODULE: "module" >
| < REQUIRES: "requires" >
| < PROVIDES: "provides" >
| < EXTENDS: "extends" >
| < DO: "do" >
| < ABSTRACT: "abstract" >
| < WHERE: "where" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* horizontal bar */

TOKEN :
{
  < BAR:
      ("---" ( "-" )* ) |
      ("\u2014\u2014\u2014" ( "\u2014" )* ) |
      ("\u2015\u2015\u2015" ( "\u2015" )* ) |
      ("\u2500\u2500\u2500" ( "\u2500" )* )
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "$",
         "A"-"Z",
         "_",
         "a"-"z",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u064a",
         "\u0671"-"\u06d3",
         "\u06d5",
         "\u06e5"-"\u06e6",
         "\u06fa"-"\u06fc",
         "\u0710",
         "\u0712"-"\u072c",
         "\u0780"-"\u07a5",
         "\u0905"-"\u0939",
         "\u093d",
         "\u0950",
         "\u0958"-"\u0961",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e1",
         "\u09f0"-"\u09f3",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a72"-"\u0a74",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abd",
         "\u0ad0",
         "\u0ae0",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3d",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c60"-"\u0c61",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d60"-"\u0d61",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0e01"-"\u0e30",
         "\u0e32"-"\u0e33",
         "\u0e3f"-"\u0e46",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb0",
         "\u0eb2"-"\u0eb3",
         "\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f40"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f88"-"\u0f8b",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u1050"-"\u1055",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17b3",
         "\u17db",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a8",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u203f"-"\u2040",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u3029",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d",
         "\ufb1f"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\uff04",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         //"-",				// added in sasyLF
         "'",				// added in sasyLF
         "\u2080"-"\u2089", // added in sasyLF (issue #46)
         "a"-"z",
         "\u007f"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u034e",
         "\u0360"-"\u0362",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u0655",
         "\u0660"-"\u0669",
         "\u0670"-"\u06d3",
         "\u06d5"-"\u06dc",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06ed",
         "\u06f0"-"\u06fc",
         "\u070f"-"\u072c",
         "\u0730"-"\u074a",
         "\u0780"-"\u07b0",
         "\u0901"-"\u0903",
         "\u0905"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc",
         "\u09be"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a02",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0",
         "\u0ae6"-"\u0aef",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbe"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17d3",
         "\u17db",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180e",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u206a"-"\u206f",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u3099"-"\u309a",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMICOLON: ";" >
| < MINUS: "-" >
| < PLUS: "+" >
| < TIMES: "*" >
| < COMMA: "," >
| < COLON: ":" >
| < DOT: "." >
| < ASSIGN: "::=" >
| < PIPE: "|" >
| < COLON_EQ: ":=" >
| < EQUAL: "=" >
}


/* USER-DEFINED OPERATORS */

TOKEN :
{
  < OPERATOR:
      [  
         "~",
         "!",
         "@",
         "#",
         "$",
         "%",
         "^",
         "&",
         "*",
         "+",
         "=",
         "|",
         "<",
         ">",
         "?",
         "\\",
	 	 "/"
      ] | "|-" |
      ~ [ // "\u2014", "\u2015", "\u2500"
          "\u0000"-"\u007f",
         "\u0080"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u034e",
         "\u0360"-"\u0362",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u0655",
         "\u0660"-"\u0669",
         "\u0670"-"\u06d3",
         "\u06d5"-"\u06dc",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06ed",
         "\u06f0"-"\u06fc",
         "\u070f"-"\u072c",
         "\u0730"-"\u074a",
         "\u0780"-"\u07b0",
         "\u0901"-"\u0903",
         "\u0905"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc",
         "\u09be"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a02",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0",
         "\u0ae6"-"\u0aef",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbe"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17d3",
         "\u17db",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180e",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u206a"-"\u206f",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u3099"-"\u309a",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"      
      ]
  >
}



/************************************
 * THE LANGUAGE GRAMMAR STARTS HERE *
 ************************************/

/*
 * Program structuring syntax follows.
 */

CompUnit CompilationUnit() :
{ PackageDeclaration pkg = null;
  String moduleName = null;
  Part p;
  QualName qn;
  List<QualName> args = new ArrayList<QualName>();
  Token s, t=null, tp;
  QualName usedModule = null;
  Location loc;
  CompUnit cu; }
{
  [ pkg=PackageDeclaration() ]
  [ LOOKAHEAD(3) firstToken=<MODULE> t=<IDENTIFIER> { moduleName = t.image; } ]
  {
    if (pkg == null)
		pkg = new PackageDeclaration(new Location(currentFile,1,1), null, new Location(currentFile,1,1));
    cu = new CompUnit(pkg, firstToken != null ? new Location(firstToken) : new Location(currentFile,1,1), moduleName);
  }
  
  (t=<REQUIRES> { if (firstToken == null) firstToken = t;
                  if (moduleName == null) ErrorHandler.recoverableError(Errors.REQUIRES_IN_MODULE,new Location(t)); }
    (
      LOOKAHEAD( ("abstract" | "terminals" | "syntax" | "judgment" | "theorem" | "lemma") )       p=Part(true) {  cu.addParameterChunk(p); }
  	)+
  )?
   
  (t=<EXTENDS> usedModule=QualName()
    { if (firstToken == null) firstToken = t;
      if (moduleName == null) ErrorHandler.recoverableError(Errors.EXTENDS_IN_MODULE, new Location(t));
      else ErrorHandler.recoverableError(Errors.EXTENDS_UNIMPLEMENTED, new Location(t)); }
  )*
   
  (t=<PROVIDES> { if (firstToken == null) firstToken = t;
                  if (moduleName == null) ErrorHandler.recoverableError(Errors.PROVIDES_IN_MODULE,new Location(t)); }
  | { if (moduleName != null) ErrorHandler.recoverableError(Errors.PROVIDES_NOT_IN_MODULE, new Location(token)); }
  )

  (
    p=Part(false) {  cu.addChunk(p); }
  | (
    	t=<MODULE> s=<IDENTIFIER> "=" usedModule=QualName() { args.clear(); loc=usedModule.getEndLocation(); }
    	[ 
    	 "[" [ qn=QualName() { args.add(qn); }
               ( "," qn=QualName() { args.add(qn); } )* ]
         tp="]" {  loc = new Location(tp); }
    	]
      	{ p = new ModulePart(new Location(t),s.image,usedModule,args,loc); cu.addChunk(p); }
    )
  )*
  <EOF>
  {
    /* maybe update first token? */
    return cu;
  }
}

void matchEOF() : {} { <EOF> { return; } }

PackageDeclaration PackageDeclaration() :
{ Token t, u; QualName q; Location e; }
{
  t=<PACKAGE> q=QualName() (u=<SEMICOLON> { e = Location.endOf(u); }| { e = q.getEndLocation(); }) { return new PackageDeclaration(new Location(t), q, e); }
}

Part Part(boolean abstractOK) :
{
  List<Syntax> syntax; Judgment j;
  Set<String> terms;
  List<Judgment> judges = new ArrayList<Judgment>();
  List<Theorem> theorems; }
{
    terms=TerminalsDeclaration() { return new TerminalsPart(terms); }
  | LOOKAHEAD(2) syntax=Syntax(abstractOK) { return new SyntaxPart(syntax); }
  | LOOKAHEAD(2) ( LOOKAHEAD(2) j=JudgmentDeclaration(abstractOK) {  judges.add(j); } ) +
  	{ return new JudgmentPart(judges);}
  | LOOKAHEAD(2) theorems=Theorems(abstractOK) { return new TheoremPart(theorems); }
}

List<Theorem> Theorems(boolean abstractOK) :
{ Theorem thm, lastThm;
  List<Theorem> theorems = new ArrayList<Theorem>(); }
{
  (	LOOKAHEAD(2)    thm=TheoremDeclaration(abstractOK) { theorems.add(thm); lastThm = thm; }
    ( "and" thm = TheoremDeclaration(false)
        { theorems.add(thm);
          lastThm.setAnd(thm);
          lastThm = thm;
        }
    )*
  )+
  {
     return theorems;
  }
}
  
Token Operator() :
{ Token t; }
{
	(
		t=<OPERATOR>
		| t=<COLON>
		| t=<COLON_EQ>
		| t=<SEMICOLON>
		| t=<MINUS>
		| t=<PLUS>
		| t=<TIMES>
		| t=<COMMA>
		| t=<PIPE>
		| t=<EQUAL>
		| t=<DOT>
		| t=<LBRACE>
		| t=<RBRACE>
	) { return t; }
}

Token Keyword() :
{ Token t; }
{
   (    t=< CASE >
    |  	t=< END >
    |   t=< CONTRADICTION >
    |   t=< CONTRACTION >
    |   t=< INVERSION >
    |   t=< WEAKENING >
    |   t=< EXCHANGE >
    |   t=< EXTENDS >
    |   t=< SUBSTITUTION >
    |   t=< USE >
    |   t=< DO >
  ) { return t; }
}
 
QualName QualName() :
{ StringSpan t;
  QualName result;
}
{
  t=RuleName() { result = new QualName(t.getLocation(), t.toString()); }
  (    "." t=RuleName() {  result = new QualName(result, t.getLocation(), t.toString()); }
  )*
  {
     return result;
  }
}  
    

StringSpan RuleName() :
{Token t, t1; StringSpan s; }
{
  (t1=<IDENTIFIER> | t1= Keyword() | t1=<IS> | t1=<NOT> | t1=<AND> | t1=<OR>) { s = new StringSpan(t1); }
  ( LOOKAHEAD({ isRulePart() }) (
      t=<MINUS>
    | t=<PLUS>
    | t=<TIMES>
    | t=<IDENTIFIER>
    | t=<INTEGER_LITERAL> 
    | t=<NOT>
    | t=<OR>
    | t=<AND>
    | t=<IS>
    | t=<LEMMA>
    | t=<THEOREM>
    | t=Keyword()) { s.add(t.image); }
  )*
  { return s; }
}

List<Syntax> Syntax(boolean abstractOK) :
{ 	Token f; Syntax s;
	List<Syntax> l = new ArrayList<Syntax>(); }
{
  f=<SYNTAX>
  ( LOOKAHEAD(2) s=BNFRule() { l.add(s); }
  | LOOKAHEAD(2) s=Sugar() {  l.add(s); }
  )+
  { if (firstToken == null) firstToken =f; return l; }
| f=<ABSTRACT> <SYNTAX>
  { if (!abstractOK) ErrorHandler.recoverableError(Errors.ABSTRACT_NOT_PERMITTED_HERE,"",new StringSpan(f),f.image + "\n"); }
  ( s=AbstractBNFRule() { l.add(s); } )+
  { return l; }
}

Token ExtendedIdentifier() :
{ Token t; }
{
	(t=<IDENTIFIER> | t=Keyword()) { return t; }
} 

Set<String> TerminalsDeclaration() :
{Token f; Token t; Set<String> l = new HashSet<String>(); }
{
  f="terminals"
  (t=ExtendedIdentifier() { debug2(t.image); l.add(t.image); getTerminal(t); } )+
  { if (firstToken == null) firstToken = f; return l; }
}

SyntaxDeclaration BNFRule() :
{ Token t;
  List<NonTerminal> alts = new ArrayList<NonTerminal>();
  QualName qn = null;
  List<Clause> l = new ArrayList<Clause>(); }
{
  t=<IDENTIFIER>
  (
    "," { alts.add(getNonTerminal(t)); } t=<IDENTIFIER>  )*
  (    "=" qn=QualName() [ <ASSIGN> Clauses(l) ]
  | <ASSIGN> Clauses(l)
  )
  {
    NonTerminal nt = getNonTerminal(t);
    SyntaxDeclaration syn;
    if (qn == null) syn = new SyntaxDeclaration(new Location(t), nt, l);
    else syn = new RenameSyntaxDeclaration(new Location(t), nt, qn, l);
    for (NonTerminal alt : alts) {
      syn.addAlternate(alt);
    }
    return syn;
  }
}

Sugar Sugar() :
{ Token t; Element e; Clause s; Clause c; }
{ ( e=Term() { s = new Clause(e); s.add(e); }
  | t=<LPAREN> { s = new Clause(new Location(t)); }
    ( e=Term() { s.add(e); } )+
    t=<RPAREN> { s.setEndLocation(new Location(t)); } )      
  <COLON_EQ> c=ExprToNL() { return new Sugar(s,c); }
}
    
SyntaxDeclaration AbstractBNFRule() :
{Token t;}
{
  t=<IDENTIFIER>
  {
    NonTerminal nt = getNonTerminal(t);
    return new SyntaxDeclaration(new Location(t), nt);
  }
}

void Clauses(List<Clause> l) :
{Clause c;}
{
  c=Clause() { if (c == null) System.err.println("empty c"); l.add(c); }
  [ "|" Clauses(l) ]
}

Clause Clause() :
{Element e; Clause c = null; }
{
  ( LOOKAHEAD({ isTermNoBARNL() }) e=Term()
    {
		if (c == null)
			c = new Clause(e);
		c.add(e);
    }
  )+
  { return c; }
}

Element Term() :
{ Token t; Element e; }
{
  LOOKAHEAD(2) e=Binding() { return e; }
  | t=<IDENTIFIER> { return getNonTerminal(t); }
  | t=<STRING_LITERAL> { Terminal tm = getTerminal(t, t.image.substring(1, t.image.length()-1)); tm.setMustQuote(); return tm; }
  | t=Operator() { return getTerminal(t); }
  | t=Keyword() { return getTerminal(t); }
  | t=<INTEGER_LITERAL> { return getTerminal(t); }
}

Binding Binding() :
{ Token t,u; Element e; List<Element> l = new ArrayList<Element>(); }
{
  t=<IDENTIFIER> "["
  	(LOOKAHEAD({ isVarBindingArg() }) e=Term()
  	 | e=Expr())
  	u="]" { l.add(e); }
  ( "[" e=Term() { l.add(e); } u="]" )*
  { return new Binding(new Location(t), getNonTerminal(t), l, new Location(u).add(1)); }
}

Judgment JudgmentDeclaration(boolean abstractOK) :
{ Token t,t_assume=null; StringSpan s; Clause c; QualName qn = null;
  Rule r; List<Rule> rules = new ArrayList<Rule>(); }
{
  (t=<ABSTRACT> <JUDGMENT> { if (!abstractOK) ErrorHandler.recoverableError(Errors.ABSTRACT_NOT_PERMITTED_HERE,"",new StringSpan(t),t.image + "\n"); }
   | t=<JUDGMENT>) s=RuleName() ["=" qn=QualName()] <COLON>
  c=ExprToNL()
  [ <ASSUMES> t_assume=<IDENTIFIER> ]
  ( LOOKAHEAD(2) r=RuleDeclaration() { rules.add(r); } )*
  {
    Location loc = new Location(t);
    String name = s.toString();
    boolean isAbstract = t.image.equals("abstract");
    NonTerminal assume = t_assume==null ? null : getNonTerminal(t_assume);
    if (isAbstract && !rules.isEmpty()) {
      ErrorHandler.recoverableError(Errors.JUDGMENT_ABSTRACT,rules.get(0));
    }
    return qn == null ? new Judgment(loc, name, isAbstract ? null : rules, c, assume)
                      : new RenameJudgment(loc, name, qn, rules, c, assume);
    }
}

Rule RuleDeclaration() :
{ Token t; StringSpan n; Clause c; List<Clause> premises = new ArrayList<Clause>(); }
{
  ( [<PREMISE>] c=ExprToNL() { premises.add(c); } )*
  t=<BAR>
  {  afterBAR(); }
  n=RuleName() 
  c=ExprToNL() { return new Rule(new Location(t), n.toString(), premises, c); }
}

Clause ExprToNL() :
{ Token t, t1, t2; Element e; Clause a, c = null; }
{
  ( t1=<LPAREN> e=Expr() (t=<AND> c=Expr() { AndJudgment.addAnd((Clause)e,makeSpan(t),c); c = null; } )* t2=<RPAREN>
	{
		c = new Clause(new Location(t1));
		c.add(e);
		c.setEndLocation(new Location(t2).add(1));
	}
    | e=Term()
	{
		c = new Clause(e);
		c.add(e);
	}
    | t=<NOT>
    {
        c = new Clause(new Location(t));
		c.add(getNonTerminal(t)); // strange, but NonTerminal knows how to handle these keywords
	}
  )
  (
    LOOKAHEAD({ isTermNoNL() }) e=Term()
	{
		c.add(e);
	}
    | LOOKAHEAD({ lParenNoNL() })
    <LPAREN> e=Expr() (t=<AND> a=Expr() { AndJudgment.addAnd((Clause)e,makeSpan(t),a); } )*t2=<RPAREN>
	{
		c.add(e);
		c.setEndLocation(new Location(t2).add(1));
	}
    |  LOOKAHEAD( {  isLogicNoNL() })
    (t=<NOT>) 
	{ 
		c.add(getNonTerminal(t));
	}
  )*
  { return c; }
}

Clause Expr() :
{ Token t, t1, t2; Element e; Clause c = null, c2, a; }
{
  (
    LOOKAHEAD({ isTerm() }) e=Term()
	{
		if (c == null)
			c = new Clause(e);
		c.add(e);
	}
	| (t=<OR>|t=<NOT>) 
		{ 
			if (c == null) c = new Clause(new Location(t));
			c.add(getNonTerminal(t)); // strange, but NonTerminal knows how to handle these keywords
	    }
    | t1=<LPAREN> c2=Expr() (t=<AND> a=Expr() { AndJudgment.addAnd(c2,makeSpan(t),a); a = null; } )*
      t2=<RPAREN>
	{
		if (c == null)
			c = new Clause(new Location(t1));
		c.add(c2);
		c.setEndLocation(new Location(t2).add(1));
	}
  )+
  { return c; }
}

Clause SimpleExpr() :
{ Element e; Clause c = null, a, c2; Token t, t2; }
{
  (
    LOOKAHEAD(<IDENTIFIER>) e=Term()
	{
		c = new Clause(e);
		c.add(e);
	}
    | t=<LPAREN> e=Expr()
      [ <ASSUMES> a=Expr() { e = new AssumptionElement(e.getLocation(), e, a); } ]
      t2=<RPAREN>
	{
		c = new Clause(new Location(t));
		c.add(e);
		c.setEndLocation(new Location(t2).add(1));
	}
	| t=<INTEGER_LITERAL>
	{  
		e = getTerminal(t);
		c = new Clause(e);
		c.add(e); 
	}
	| t=<LBRACE>
	  { c = new Clause(new Location(t)); }
	  (	    t=<IDENTIFIER> { c.add(getNonTerminal(t)); }
	  | t=<COMMA> { } // not added (unordered)
	  | t=<LPAREN> { c2 = new Clause(new Location(t)); }
	    (
	  	  LOOKAHEAD(<IDENTIFIER>|<LBRACE>)
	  	  a=SimpleExpr() {  c2.add(a); }
	    | t2=<COMMA> { c2.add(getTerminal(t2)); } // added (ordered)	  	| t2=<OPERATOR> { c2.add(getTerminal(t2)); } // needed for ">"
	    )*
	    t=<RPAREN> { c2.setEndLocation(new Location(t).add(1));
	                 c.add(c2); }
	  )*
	  t2=<RBRACE>
	{
	  c.setEndLocation(new Location(t2).add(1));
	}
  )
  { return c; }
}

Element NonTerminalOrBinding() :
{ Element e; Token t; }
{
  LOOKAHEAD({ isBinding() }) e=Binding() { return e; }
  | t=<IDENTIFIER> { return getNonTerminal(t); }
}

Element WhereLHS() :
{ Element e; }
{
  e=NonTerminalOrBinding() { return e; }
  | <LPAREN> e=NonTerminalOrBinding() <RPAREN> { return e; } // one set of parens allowed
}

WhereClause WhereClauses() :
{
  Token t, badt = null;
  WhereClause result = new WhereClause();
  Element lhs;
  Clause rhs;
}
{
    ( t=<WHERE> lhs=WhereLHS() (<COLON_EQ>|badt=":"|badt="=") rhs=ExprToNL()
    {
      result = new WhereClause(new Location(t));
      result.add(lhs, rhs);
      if (badt != null) {
        ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_COLONEQ, "'" + badt.image + "'",
                                      new StringSpan(badt));
        badt = null;
      }
    }
  	  ( <AND> lhs=WhereLHS() (<COLON_EQ>|badt=":"|badt="=") rhs=ExprToNL()
  	  {
        result.add(lhs, rhs);
        if (badt != null) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_COLONEQ, "'" + badt.image + "'",
                                      new StringSpan(badt));
          badt = null;
        }
      }
      )*
    )?
  {
     return result;
   }
}
  
Theorem TheoremDeclaration(boolean abstractOK) :
{ Token tinit = null, t0, t, tp=null; StringSpan s, sp=null; Clause c; Clause a = null; Binding b; Theorem thm; Derivation d; }
{
  (tinit=<ABSTRACT>) ?
  (t0=<THEOREM> | t0=<LEMMA>) s=RuleName() <COLON>
  { if (tinit == null) tinit = t0;
    else if (!abstractOK) ErrorHandler.recoverableError(Errors.ABSTRACT_NOT_PERMITTED_HERE,"",new StringSpan(tinit),tinit.image + "\n");
    thm = new Theorem(s.toString(), new Location(tinit), tinit != t0); }
  [ <ASSUMES> t=<IDENTIFIER> { thm.setAssumes(getNonTerminal(t)); } ]
  ( LOOKAHEAD(3) <FORALL> t=<IDENTIFIER> <COLON> c=Expr()
    { thm.getForalls().add(new DerivationByAssumption(t.image, new Location(t), c)); }
  | LOOKAHEAD(3) <FORALL> b=Binding() [ <ASSUMES> a=Expr() ]
    { thm.getForalls().add(new BindingAssumption(b, a)); a = null; }
  | <FORALL> t=<IDENTIFIER> [ <ASSUMES> a=Expr() ]
    { thm.getForalls().add(new NonTerminalAssumption(t.image, new Location(t), true, a)); a = null; }
  )*
  <EXISTS> c=ExprToNL()
  	(t=<AND> a=ExprToNL() { AndJudgment.addAnd(c,new Location(t),a); a = null; }
    |t=<OR> a=ExprToNL() {  OrJudgment.addOr(c,new Location(t),a); a = null; }  )*
    { thm.setExists(c); }
  ( d=Derivation() { thm.getDerivations().add(d); } )*
  <END> (tp=<THEOREM> | tp=<LEMMA> | sp=RuleName() { tp = null; } )
  { 
    if (tp == null) {
        ErrorHandler.recoverableError(Errors.WRONG_END,"'end " + t0.image + "'",
        	sp, sp.toString() + "\n" + t0.image);
        thm.setEndLocation(sp.getEndLocation());
    } else if (!tp.image.equals(t0.image)) {
        ErrorHandler.recoverableError(Errors.WRONG_END,"'end " + t0.image + "'", 
        	new TokenSpan(tp),tp.image + "\n" + t0.image); 
    }
    thm.setKind(t0.image);
    if (tp != null) thm.setEndLocation(Location.endOf(tp));
    return thm; 
  }
}

Derivation Derivation() :
{ Token t; Token t2; Token a; StringSpan s; QualName q = null; Case ca; Clause c; Clause c2 = null; Derivation d; Token of = null;}
{
   (
     t=<IDENTIFIER> <COLON> c=Expr()
   (a=<AND> t2=<IDENTIFIER> <COLON> c2=Expr()
     { t.image = t.image+","+t2.image;
       AndJudgment.addAnd(c,new Location(a),c2); })*
     |
     t=<PROOF> { c = null; })
   <BY> d=Justification(t, c)
  { return d; }
| LOOKAHEAD(<USE> <INVERSION>)
  (    t=<USE> t2=<INVERSION> (of=<IDENTIFIER> [<RULE>] q=QualName() [<ON> c2=SimpleExpr()]
                        |<ON> c2=SimpleExpr())
    {
	  Element lhs=null; Clause rhs=null;
	  WhereClause whereClauses = null;
      if (c2 == null) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INVERSION_ON,new TokenSpan(t2));
          c2 = new Clause(q.getLocation());
      } else if (of != null && !of.image.equals("of")) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INVERSION_OF,"'inversion " + of.image + "'", new Location(of));
      }
    }
    whereClauses=WhereClauses()
    {
      return new DerivationByInversion("_", new Location(t), c2.getEndLocation(),
    	 AndClauseUse.makeEmptyAndClause(new Location(t)), q, c2, whereClauses);
    }
  )
|  t=<USE> <INDUCTION> <ON> c2=SimpleExpr()
	{ d = new DerivationByInduction(t.image, new Location(t), AndClauseUse.makeEmptyAndClause(new Location(t))); 
	  ((DerivationWithArgs)d).addArgString(c2); }
	( <COMMA> c2=SimpleExpr() { ((DerivationWithArgs)d).addArgString(c2); } )* 
	{ return d; }
|  t=<DO> <CASE> <ANALYSIS> <ON> c=SimpleExpr()
     { d = new PartialCaseAnalysis(new Location(t),c); }
        <COLON>
    ( ca=Case() { if (ca != null) ((DerivationByAnalysis)d).getCases().add(ca); })*
    of=<END> 
   ( LOOKAHEAD(2) <CASE> t=<ANALYSIS> |
     (t=<CASE> | t=<INDUCTION> | t=<LEMMA> | t=<THEOREM> )
     { ErrorHandler.recoverableError(Errors.WRONG_END,"'end case analysis'",new TokenSpan(t),t.image+"\ncase analysis"); } )
    { d.setEndLocation(Location.endOf(t)); return d; }
    
}

Derivation Justification(Token startT, Clause c) :
{ Token t=null; Token t2; Derivation d; DerivationWithArgs da; DerivationByInduction di; Case ca;
  DerivationByCaseAnalysis dca; StringSpan s; QualName q = null; Element e; Clause cl = null; Token of = null; QualName qn;
}
{ // args should include expressions
  <RULE> qn=QualName() { da=new DerivationByRule(startT.image, new Location(startT), c, qn); }
    [ <ON> cl=SimpleExpr() { da.addArgString(cl); }
      ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )* 
    ]
    { return da; }
  | (t=<THEOREM> | t=<LEMMA>) qn=QualName() { da=new DerivationByTheorem(startT.image, new Location(startT), c, qn, new StringSpan(t)); }
    [ <ON> cl=SimpleExpr() { da.addArgString(cl); }
      ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )* 
    ]
    { return da; }
  | LOOKAHEAD(2) <INDUCTION> <ON> cl=SimpleExpr()
    { di = new DerivationByInduction(startT.image, new Location(startT), c, cl); }
      ( <COMMA> cl=SimpleExpr() { di.addArgString(cl); } )* 
    <COLON>
    ( ca=Case() { if (ca != null) di.getCases().add(ca); })*
    of=<END> 
    (t=<INDUCTION> |
     (LOOKAHEAD(2) <CASE> t=<ANALYSIS> | t=<CASE> | t=<LEMMA> | t=<THEOREM>)
     { String wrong = t.image;
       if (wrong.equals("analysis")) wrong = "case analysis";
       ErrorHandler.recoverableError(Errors.WRONG_END,"'end induction'",new TokenSpan(t),wrong+"\ninduction"); } )
    { di.setEndLocation(Location.endOf(t)); return di; }
  | LOOKAHEAD(2) <CASE> <ANALYSIS> <ON> cl=SimpleExpr()
    { dca = new DerivationByCaseAnalysis(startT.image, new Location(startT), c, cl); }
      ( <COMMA> cl=SimpleExpr() { dca.addArgString(cl); } )* 
    <COLON>
    ( ca=Case() { if (ca != null) dca.getCases().add(ca); })*
    of=<END> 
    ( LOOKAHEAD(2) <CASE> t=<ANALYSIS> |
     (t=<CASE> | t=<INDUCTION> | t=<LEMMA> | t=<THEOREM> )
     { ErrorHandler.recoverableError(Errors.WRONG_END,"'end case analysis'",new TokenSpan(t),t.image+"\ncase analysis"); } )
    { dca.setEndLocation(Location.endOf(t)); return dca; }
  | LOOKAHEAD(2) <CONTRADICTION> <ON> t=<IDENTIFIER>
    { dca = new DerivationByCaseAnalysis(startT.image, new Location(startT), c, t.image); 
      dca.setEndLocation(Location.endOf(t)); return dca; }
  | LOOKAHEAD(4)
  (	<INVERSION> [of=<IDENTIFIER>] <OR> <ON> cl=SimpleExpr()
	{
	  Element lhs=null; Clause rhs=null;
	  WhereClause whereClauses = null;
      if (of == null) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INVERSION_OF, "'inversion'",cl);
      } else if (!of.image.equals("of")) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INVERSION_OF, "'inversion " + of.image + "'", new Location(of));
      }
    }
    whereClauses=WhereClauses()
    {
   	  return new DerivationByInversion(startT.image, new Location(startT), cl.getEndLocation(),
   	      c, DerivationByInversion.OR, cl, whereClauses);
	}
  ) 
  | LOOKAHEAD(3)
  (
    t2=<INVERSION> (of=<IDENTIFIER> [<RULE>] q=QualName() [<ON> cl=SimpleExpr()]
                   |<ON> cl=SimpleExpr()) 
    {
	  Element lhs=null; Clause rhs=null;
	  WhereClause whereClauses = null;
      if (cl == null) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INVERSION_ON,new TokenSpan(t2));
          cl = new Clause(q.getLocation());
      } else if (of != null && !of.image.equals("of")) {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INVERSION_OF, "'inversion " + of.image + "'", new Location(of));
      }
    }
    whereClauses=WhereClauses()
    {
   	  return new DerivationByInversion(startT.image, new Location(startT), cl.getEndLocation(),
   	      c, q, cl, whereClauses);
	}
  )
  | <INDUCTION> t=<HYPOTHESIS> (<ON> cl=SimpleExpr() | {cl = null; })
    { da = new DerivationByInductionHypothesis(startT.image, new Location(startT), c);
      if (cl != null) {
          da.addArgString(cl);
      } else {
          ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_INDUCTION_HYPO_ON, new Location(t));
      }
    }
    ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )*
    { return da; }
  | <SUBSTITUTION> <ON> t=<IDENTIFIER>
    { 
      da = new DerivationBySubstitution(startT.image, new Location(startT), c);
      da.addArgString(clauseFor(t));
    }
    ( <COMMA> t=<IDENTIFIER> { da.addArgString(clauseFor(t)); } )* 
    { return da; }
  | t=<UNPROVED>
    { d = new DerivationUnproved(startT.image, new Location(startT), c);
      d.setEndLocation(Location.endOf(t)); 
      return d; }
  | t=<SOLVE>
    { d = new DerivationBySolve(startT.image, new Location(startT), c);
      d.setEndLocation(Location.endOf(t)); 
      return d; }
  | <EXCHANGE> <ON> t=<IDENTIFIER>
    { da = new DerivationByExchange(startT.image, new Location(startT), c);
      da.addArgString(clauseFor(t)); }
    ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )* 
    { return da; }
  | <WEAKENING> <ON> t=<IDENTIFIER>
    { da = new DerivationByWeakening(startT.image, new Location(startT), c);
      da.addArgString(clauseFor(t)); }
    ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )* 
    { return da; }
  | LOOKAHEAD({isRulePart2()}) qn = QualName() 
     { da=new DerivationByTheorem(startT.image, new Location(startT), c, qn, null); }
     (<ON> cl=SimpleExpr() { da.addArgString(cl); }
      ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )* | {} )
     { // handled later: ErrorHandler.recoverableError("Missing keyword 'rule' or 'theorem'/'lemma' before name", new Location(startT));
       return da;
     }
  | LOOKAHEAD(2) t=<IDENTIFIER> {qn = new QualName(new Location(t), t.image);} 
     { da=new DerivationByTheorem(startT.image, new Location(startT), c, qn, null); }
     <ON> cl=SimpleExpr() { da.addArgString(cl); }
      ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )* 
     { // handled later: ErrorHandler.recoverableError("Missing keyword 'rule' or 'theorem'/'lemma' before name", new Location(t));
       return da;
     }
  | cl=SimpleExpr()
    { da = new DerivationByPrevious(startT.image, new Location(startT), c);
      da.addArgString(cl);
    }
    ( <COMMA> cl=SimpleExpr() { da.addArgString(cl); } )*
	{ return da; }
}

Case Case() :
{ Token first=null, t,t2,t3,u,a; StringSpan s; QualName q;
  Clause cl,ce=null,c2; Case ca; Derivation d;
  List<Derivation> premises = new ArrayList<Derivation>();
  Element lhs=null;
  Clause rhs=null;
  WhereClause whereClauses = null;
  Location endLoc=null;
}
{
  LOOKAHEAD(2) d=Derivation() {
    ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_CASE,d);
    return null;
  }
  | 
  ( LOOKAHEAD(2) t=<CASE> <OR> t3=<IDENTIFIER> <COLON> ce=Expr() 
    (a=<AND> t2=<IDENTIFIER> <COLON> c2=Expr()
     { t3.image = t3.image+","+t2.image; AndJudgment.addAnd(ce,new Location(a),c2); })*
    { ca = new OrCase(new Location(t),new DerivationByAssumption(t3.image, new Location(t3), ce)); }
  | LOOKAHEAD(2) t=<CASE> cl=Expr() [<ASSUMES> ce=Expr()] { ca = new SyntaxCase(new Location(t), cl, ce); }
  | t=<CASE> <RULE>
    ( [first=<PREMISE>] t3=<IDENTIFIER> <COLON> ce=ExprToNL()
      {
        if (first == null)
          first = t3;
        premises.add(new DerivationByAssumption(t3.image, new Location(t3), ce));
      }
    )*
    u=<BAR>
    {  afterBAR(); }
    q=QualName()
    t3=<IDENTIFIER> <COLON> ce=Expr()
    {
      endLoc = ce.getEndLocation();
    }
    whereClauses=WhereClauses()
    {
      if (first == null)
      	first = u;
      ca = new RuleCase(
		new Location(t),
		new Location(first),
		endLoc,
		q,
		premises,
		new DerivationByAssumption(t3.image, new Location(t3), ce),
		whereClauses
	  );
    }
  )
    <IS>
    ( ( d=Derivation() { ca.getDerivations().add(d); } )+
    | { ErrorHandler.recoverableError(Errors.PARSE_EXPECTED_DERIVATION, new Location(t)); } )
    t=<END> 
    (LOOKAHEAD(2) u=<CASE> |
     (<CASE> u=<ANALYSIS> | u=<INDUCTION> | u=<LEMMA> | u=<THEOREM>)
     { String bad = u.image;
       if (bad.equals("analysis")) bad = "case analysis";
       ErrorHandler.recoverableError(Errors.WRONG_END,"'end case'",new TokenSpan(u),bad+"\ncase"); } )
    { ca.setEndLocation(Location.endOf(u));
      return ca; }
}


